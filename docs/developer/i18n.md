# Internationalization Setup

## Overview
This document details the internationalization (i18n) system implemented in the storefront base template. The system provides multi-language support, region-based content delivery, and localization capabilities.

## Current Implementation

### Region-Based Routing
The storefront implements region-based routing using Next.js dynamic routes:

1. **Country Code URLs**
   - Routes are prefixed with country codes (e.g., `/us/`, `/de/`, `/fr/`)
   - Automatic redirection based on detected region
   - Fallback to default region when needed

2. **Middleware Processing**
   - Region detection in `src/middleware.ts`
   - Vercel IP geolocation headers
   - URL-based region specification
   - Cookie-based caching for consistent experience

3. **Region Data Integration**
   - Fetching regions from Medusa backend
   - Caching region data for performance
   - Mapping countries to regions
   - Regional pricing and availability

### Current Limitations
1. Basic region-based routing without full translation management
2. No UI language switching mechanism
3. Limited content localization capabilities
4. No RTL (Right-to-Left) language support
5. No locale-based formatting for dates, numbers, and currencies

## Planned Enhanced Internationalization System

### Multi-Language Support
Implementation of comprehensive multi-language support:

1. **Translation Management**
   - JSON-based translation files
   - Namespace organization
   - Fallback language handling
   - Dynamic loading of translations

2. **Language Detection**
   - Browser language preference
   - User preference storage
   - Geolocation-based suggestions
   - Manual language selection

3. **Translation Loading Strategy**
   ```typescript
   // Example translation loader
   export async function loadTranslations(locale: string) {
     try {
       const translations = await import(`../locales/${locale}.json`)
       return translations.default
     } catch (error) {
       // Fallback to default language
       const defaultTranslations = await import('../locales/en.json')
       return defaultTranslations.default
     }
   }
   ```

### Translation System Architecture

#### File Structure
```
src/
├── locales/
│   ├── en.json
│   ├── de.json
│   ├── fr.json
│   └── es.json
├── lib/
│   └── i18n/
│       ├── index.ts
│       ├── client.ts
│       └── server.ts
└── modules/
    └── common/
        └── components/
            └── language-selector/
```

#### Translation Files Format
```json
{
  "common": {
    "navigation": {
      "home": "Home",
      "products": "Products",
      "account": "Account",
      "cart": "Cart"
    },
    "actions": {
      "save": "Save",
      "cancel": "Cancel",
      "delete": "Delete",
      "edit": "Edit"
    }
  },
  "product": {
    "details": {
      "price": "Price",
      "description": "Description",
      "addToCart": "Add to Cart"
    }
  }
}
```

#### Translation Hook
```typescript
// hooks/use-translations.ts
import { useContext } from "react"
import { TranslationContext } from "@/lib/i18n/client"

export function useTranslations(namespace?: string) {
  const { t } = useContext(TranslationContext)

  return namespace ? (key: string) => t(`${namespace}.${key}`) : t
}
```

### Right-to-Left (RTL) Language Support

#### CSS Direction Management
Implementation of RTL support through CSS direction properties:

1. **HTML Direction Attribute**
   ```html
   <html dir={isRTL ? 'rtl' : 'ltr'} lang={currentLocale}>
   ```

2. **Tailwind RTL Variants**
   ```css
   /* tailwind.config.js */
   module.exports = {
     plugins: [require('tailwindcss-rtl')],
   }
   ```

3. **Component Adaptation**
   ```tsx
   // Example component with RTL support
   export function Navigation() {
     const { isRTL } = useLanguage()

     return (
       <nav className={`flex ${isRTL ? 'flex-row-reverse' : 'flex-row'}`}>
         {/* Navigation items */}
       </nav>
     )
   }
   ```

### Locale-Based Formatting

#### Date Formatting
Implementation of locale-aware date formatting:

```typescript
// utils/date-formatting.ts
export function formatDate(date: Date, locale: string): string {
  return new Intl.DateTimeFormat(locale, {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }).format(date)
}
```

#### Number Formatting
Locale-aware number formatting:

```typescript
// utils/number-formatting.ts
export function formatNumber(value: number, locale: string, options?: Intl.NumberFormatOptions): string {
  return new Intl.NumberFormat(locale, {
    maximumFractionDigits: 2,
    ...options
  }).format(value)
}
```

#### Currency Formatting
Region-aware currency formatting:

```typescript
// utils/currency-formatting.ts
export function formatCurrency(amount: number, currencyCode: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: currencyCode,
  }).format(amount)
}
```

### Language Switcher Component

#### UI Implementation
```tsx
// components/language-switcher.tsx
"use client"

import { useLanguage } from "@/lib/i18n/client"

export function LanguageSwitcher() {
  const { currentLocale, availableLocales, changeLanguage } = useLanguage()

  return (
    <select
      value={currentLocale}
      onChange={(e) => changeLanguage(e.target.value)}
      className="border rounded p-2"
    >
      {availableLocales.map((locale) => (
        <option key={locale.code} value={locale.code}>
          {locale.name}
        </option>
      ))}
    </select>
  )
}
```

#### Server Component Integration
```tsx
// app/[countryCode]/layout.tsx
import { LanguageSwitcher } from "@/components/language-switcher"
import { getAvailableLanguages } from "@/lib/i18n/server"

export default async function LocaleLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: { countryCode: string }
}) {
  const availableLanguages = await getAvailableLanguages()

  return (
    <html lang={params.countryCode}>
      <body>
        <header>
          <LanguageSwitcher languages={availableLanguages} />
        </header>
        <main>{children}</main>
      </body>
    </html>
  )
}
```

### Content Localization Strategy

#### Dynamic Content Loading
Implementation of dynamic content loading based on locale:

```typescript
// lib/content/localization.ts
export async function getLocalizedContent(contentId: string, locale: string) {
  // Try to fetch localized version
  try {
    const localizedContent = await fetch(`/api/content/${contentId}?locale=${locale}`)
    if (localizedContent.ok) {
      return localizedContent.json()
    }
  } catch (error) {
    // Fall back to default content
    const defaultContent = await fetch(`/api/content/${contentId}`)
    return defaultContent.json()
  }
}
```

#### SEO Considerations
Implementation of SEO-friendly localization:

1. **Hreflang Tags**
   ```html
   <link rel="alternate" hrefLang="en-US" href="https://example.com/us/" />
   <link rel="alternate" hrefLang="de-DE" href="https://example.com/de/" />
   <link rel="alternate" hrefLang="x-default" href="https://example.com/us/" />
   ```

2. **Canonical URLs**
   ```html
   <link rel="canonical" href="https://example.com/us/" />
   ```

3. **Localized Meta Tags**
   ```tsx
   export const metadata: Metadata = {
     title: {
       default: 'Localized Title',
       template: `%s | Localized Site Name`,
     },
     description: 'Localized description',
   }
   ```

### Migration Path

#### From Current Implementation
Steps to migrate from the current region-based routing to full i18n:

1. **Phase 1: Foundation**
   - Implement translation file structure
   - Add translation loading utilities
   - Create language context provider

2. **Phase 2: Integration**
   - Integrate translation hooks into components
   - Add language switcher UI
   - Implement locale-based formatting

3. **Phase 3: Enhancement**
   - Add RTL language support
   - Implement content localization
   - Add SEO optimizations

#### Backward Compatibility
Ensure backward compatibility during migration:

1. Maintain existing region-based URLs
2. Provide fallback to English for missing translations
3. Support gradual migration of components
4. Document migration steps for developers

### Best Practices

#### Translation Management
1. Use consistent key naming conventions
2. Organize translations by feature/module
3. Provide context comments for translators
4. Regularly audit translation completeness
5. Implement translation validation tools

#### Performance Considerations
1. Lazy-load translation files
2. Cache translation data appropriately
3. Minimize bundle size impact
4. Optimize translation loading sequences
5. Use static generation where possible

#### Accessibility
1. Ensure language switchers are accessible
2. Maintain proper language attributes
3. Support screen reader language switching
4. Provide keyboard navigation for selectors
5. Test with assistive technologies

#### SEO Optimization
1. Implement hreflang tags correctly
2. Use canonical URLs for translated content
3. Optimize meta tags for each locale
4. Submit sitemaps for each language
5. Monitor crawl errors by locale